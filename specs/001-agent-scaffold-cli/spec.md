# Feature Specification: Azure Agent Starter Pack CLI

**Feature Branch**: `001-agent-scaffold-cli`  
**Created**: 2025-02-25  
**Status**: Draft  
**Input**: Define a full feature specification for an open-source CLI that scaffolds Azure AI Agent projects with configurable options. Installation via `uv tool install azure-agent-starter-pack`. Commands: init, upgrade. Configurable: framework, project type, pipeline, runtime, IaC. Functional: interactive and non-interactive mode, runnable project, CI/CD, IaC, Azure OpenAI/Foundry config, Managed Identity, Key Vault, observability, unit test scaffolding, security scanning. Non-functional: deterministic generation, &lt;5 min scaffold, deployable in 30 min, extensible adapters, versioned templates.

## Clarifications

### Session 2025-02-25

- Q: What happens when the user runs init in a non-empty directory? → A: Fail with a clear error; require an empty target directory (or explicit overwrite flag).
- Q: What happens when the user selects an unsupported or invalid combination of options? → A: Fail fast with a clear error; do not generate any files (no partial generation).
- Q: How does upgrade behave when the project has been heavily customized? → A: Auto-merge: apply template changes where possible; overwrite only template-owned files; warn on conflicts.
- Q: How does the CLI behave when network or external services are unavailable during scaffold? → A: Use cached templates only when available; if no cache and network fails, then fail with clear error.
- Q: Doctor command: which prerequisites are required vs optional? → A: Required: only what init needs (e.g. runtime, template access). Optional: everything else (e.g. Azure login, cloud CLI); report but do not fail.

## User Scenarios & Testing *(mandatory)*

### User Story 1 - First-Time Project Scaffold (Priority: P1)

A developer installs the CLI and runs a single command to generate a new Azure AI Agent project. They are prompted (or provide flags) to choose framework, project type, pipeline, runtime, and IaC. The CLI produces a runnable project with CI/CD, infrastructure-as-code, and Azure configuration placeholders. They can run tests and deploy to Azure following the generated instructions.

**Why this priority**: Core value of the product; without scaffold, no other story applies.

**Independent Test**: Run init with a fixed set of options; verify a runnable project is created, build and test pass, and deployment docs are present.

**Acceptance Scenarios**:

1. **Given** CLI is installed, **When** user runs the init command with valid options (interactive or non-interactive), **Then** a complete project is generated in the target directory with no placeholder tokens left unresolved for the chosen options.
2. **Given** a generated project, **When** user follows the generated README to install dependencies and run tests, **Then** the project builds and unit tests execute successfully.
3. **Given** a generated project, **When** user follows the generated deployment instructions, **Then** the project can be deployed to the chosen cloud runtime within the stated time goal (30 minutes for a standard path).
4. **Given** user runs init in non-interactive mode with all options supplied (e.g. via flags or env), **When** the command completes, **Then** no prompts are shown and output is deterministic for the same inputs.

---

### User Story 2 - Upgrade Existing Scaffolded Project (Priority: P2)

A developer who previously scaffolded a project with an older template version runs an upgrade command. The CLI updates template-derived files (or reports what must be changed) so the project aligns with a newer template version while preserving user customizations where possible.

**Why this priority**: Enables long-term adoption; second major command after init.

**Independent Test**: Scaffold with version N, change template to version N+1, run upgrade; verify documented upgrade path and no broken state.

**Acceptance Scenarios**:

1. **Given** a project that was generated by the CLI, **When** user runs the upgrade command from the project root, **Then** the CLI detects the project type and template version and offers or applies an upgrade path.
2. **Given** an upgrade is applied, **When** user runs build and tests, **Then** the project still runs and tests pass unless the upgrade documentation states otherwise.
3. **Given** user runs upgrade in a directory that is not a scaffolded project, **When** the command runs, **Then** the CLI exits with a clear error and does not modify files.

---

### User Story 3 - Configure Framework and Project Type (Priority: P1)

A developer chooses one of the supported agent frameworks (e.g. Google ADK, Microsoft Agent Framework, CrewAI, LangGraph) and one project type (e.g. multi-agent with API, multi-agent with chat UI, agentic RAG with search). The generated project reflects these choices and runs with the selected stack.

**Why this priority**: Central to differentiation; users must get the stack they chose.

**Independent Test**: For each supported framework and project-type combination (or a representative subset), run init and verify the generated app runs and matches the chosen options.

**Acceptance Scenarios**:

1. **Given** user selects Framework A and Project Type B, **When** init completes, **Then** the generated project uses Framework A and matches the structure and entrypoints for Project Type B (e.g. API vs chat UI vs RAG).
2. **Given** user selects a pipeline (e.g. Azure DevOps or GitHub Actions), **When** init completes, **Then** the project contains a working pipeline definition that runs build, test, and security scanning.
3. **Given** user selects a runtime (e.g. AKS, Container Apps, App Service) and IaC (e.g. Terraform or Bicep), **When** init completes, **Then** the project contains infrastructure-as-code that targets the selected runtime and can be applied to provision the environment.

---

### User Story 4 - Azure Integration and Security Defaults (Priority: P1)

A developer receives a project that is Azure-native by default: Azure OpenAI and Azure AI Foundry (or equivalent) configuration is injected as placeholders or wiring, authentication uses Managed Identity, and a Key Vault integration example is included. Observability hooks and security scanning are present in the pipeline.

**Why this priority**: Aligns with constitution; production-ready and secure-by-default.

**Independent Test**: After scaffold, verify no hardcoded secrets; verify pipeline runs SAST and dependency scan; verify observability and Key Vault example exist.

**Acceptance Scenarios**:

1. **Given** a generated project, **When** the user inspects configuration and code, **Then** there are no hardcoded secrets; Azure resource access uses Managed Identity or Key Vault references.
2. **Given** a generated project, **When** the user runs the CI pipeline, **Then** security scanning (SAST and dependency scan) runs and results are visible.
3. **Given** a generated project, **When** the user runs the application, **Then** observability hooks (e.g. logging and metrics) are present and can be connected to Azure Monitor (or equivalent).
4. **Given** a generated project, **When** the user reads the documentation, **Then** Key Vault integration is documented or exemplified for secrets.

---

### User Story 5 - Deterministic and Fast Scaffolding (Priority: P2)

A developer or CI job runs the same init command twice with the same options; the generated output is identical. Scaffolding completes in under five minutes on typical hardware. A doctor (or equivalent) command validates environment and configuration.

**Why this priority**: Required for automation and trust; supports CI and reproducible workflows.

**Independent Test**: Run init twice with same options, diff output; run init and measure time; run doctor and verify it checks prerequisites.

**Acceptance Scenarios**:

1. **Given** the same CLI version, template version, and options, **When** init is run twice in empty directories, **Then** the two generated trees are identical (deterministic).
2. **Given** a standard developer machine, **When** user runs init with default or common options, **Then** the command completes in under five minutes.
3. **Given** the CLI is installed, **When** user runs the doctor command, **Then** the CLI reports pass/fail for required prerequisites (what init needs, e.g. runtime, template access) and reports status and hints for optional ones (e.g. Azure login, cloud CLI) without failing.

---

### Edge Cases

- When the user runs init in a non-empty directory, the CLI MUST fail with a clear error and require an empty target directory (or an explicit overwrite flag if provided); it MUST NOT merge or silently overwrite.
- When the user selects an unsupported or invalid combination of options, the CLI MUST fail fast with a clear error and MUST NOT generate any files (no partial generation).
- When network or external services are unavailable during scaffold, the CLI MUST use cached templates when available; when no cache exists and fetch fails, it MUST fail with a clear error (no partial generation).
- When the project has been heavily customized, upgrade MUST apply template changes where possible, overwrite only template-owned files, and warn on conflicts; the merge strategy MUST be documented.
- When init is run without an interactive TTY (e.g. CI), the CLI MUST treat the run as non-interactive: it MUST NOT block on prompts; if any required option is missing, it MUST fail with a clear error. All options MUST be supplied via flags or environment (FR-005).

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: The CLI MUST be installable via `uv tool install azure-agent-starter-pack`.
- **FR-002**: The CLI MUST provide an `init` command that scaffolds a new Azure AI Agent project.
- **FR-003**: The CLI MUST provide an `upgrade` command that updates an existing scaffolded project to a newer template version by applying template changes where possible, overwriting only template-owned files, and warning on conflicts (or reporting upgrade path when auto-merge is not applicable).
- **FR-004**: The CLI MUST support interactive prompts for configuration options when run in an interactive context.
- **FR-005**: The CLI MUST support non-interactive mode (flags or environment) so that all options can be supplied without prompts, suitable for CI.
- **FR-006**: The CLI MUST allow the user to choose one framework from a defined set (e.g. Google ADK, Microsoft Agent Framework, CrewAI, LangGraph).
- **FR-007**: The CLI MUST allow the user to choose one project type from a defined set (e.g. multi-agent with API, multi-agent with React chat UI, agentic RAG with Azure AI Search).
- **FR-008**: The CLI MUST allow the user to choose one pipeline from a defined set (e.g. Azure DevOps, GitHub Actions).
- **FR-009**: The CLI MUST allow the user to choose one runtime environment from a defined set (e.g. AKS, Azure Container Apps, Azure App Service).
- **FR-010**: The CLI MUST allow the user to choose one IaC approach from a defined set (e.g. Terraform, Bicep).
- **FR-011**: Generated projects MUST be runnable (build, test, and run) using only the generated assets and documented prerequisites.
- **FR-012**: Generated projects MUST include CI/CD pipeline definitions for the selected pipeline option.
- **FR-013**: Generated projects MUST include infrastructure-as-code for the selected IaC and runtime.
- **FR-014**: Generated projects MUST include placeholders or wiring for Azure OpenAI and Azure AI Foundry (or equivalent) configuration.
- **FR-015**: Generated projects MUST use Managed Identity for Azure resource authentication where applicable.
- **FR-016**: Generated projects MUST include a Key Vault integration example or documentation.
- **FR-017**: Generated projects MUST include observability hooks (e.g. OpenTelemetry and Azure Monitor integration).
- **FR-018**: Generated projects MUST include unit test scaffolding so developers can add and run tests.
- **FR-019**: The generated CI/CD pipeline MUST include security scanning (e.g. SAST and dependency scan).
- **FR-020**: The CLI MUST provide a doctor (or equivalent) command that validates environment and configuration. Required checks MUST be only what init needs (e.g. runtime, template access); all other checks (e.g. Azure login, cloud CLI) are optional and MUST be reported but MUST NOT cause doctor to fail.
- **FR-021**: The CLI MUST require the init target directory to be empty (or an explicit overwrite flag); when the directory is non-empty and overwrite is not requested, init MUST fail with a clear error and MUST NOT modify files.
- **FR-022**: For an unsupported or invalid combination of options, the CLI MUST fail fast with a clear error and MUST NOT generate any files (no partial generation).
- **FR-023**: When template fetch fails (e.g. network unavailable), the CLI MUST use cached templates when available; when no cache exists, it MUST fail with a clear error and MUST NOT generate any files.

### Non-Functional Requirements

- **NFR-001**: Template generation MUST be deterministic: same CLI version, template version, and options MUST produce identical output.
- **NFR-002**: Scaffold (init) MUST complete in under five minutes on typical developer hardware for standard options.
- **NFR-003**: A generated project MUST be deployable to Azure within 30 minutes when following the generated instructions and using the chosen runtime and IaC.
- **NFR-004**: The CLI MUST support an extensible framework adapter system so new frameworks or options can be added without replacing the core.
- **NFR-005**: Templates MUST be versioned and selectable; the CLI MUST support versioned template management and backward-compatible upgrade paths where feasible.

### Key Entities

- **Project configuration**: The set of user choices (framework, project type, pipeline, runtime, IaC) that define what is generated.
- **Template**: Versioned set of files and rules used to produce a project; may be composed (e.g. base + framework + project type).
- **Scaffolded project**: The output directory and files produced by init for a given configuration.
- **Pipeline definition**: The CI/CD workflow (e.g. YAML) included in the project for the selected pipeline provider.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Users can generate a runnable Azure AI Agent project with a single command in under five minutes.
- **SC-002**: Users can deploy the generated project to Azure within 30 minutes when following the generated instructions.
- **SC-003**: The same init options produce identical output on repeated runs (deterministic).
- **SC-004**: Users can run init in CI without interaction and get a complete, buildable project.
- **SC-005**: Generated projects pass their own CI pipeline (build, test, security scan) when run in a clean environment.
- **SC-006**: Doctor command correctly reports pass/fail for required prerequisites (init needs only) and reports optional checks with actionable guidance when something is missing; doctor fails only when a required check fails.

## Out of Scope

- **Full provisioning engine**: The CLI scaffolds structure and pipelines; it does not replace a general-purpose provisioning or orchestration engine for arbitrary Azure resources beyond what is needed for the scaffolded app.
- **Low-code or no-code authoring**: Output is code and IaC for developers; the CLI does not provide a proprietary low-code runtime or visual designer.
- **Framework lock-in**: The CLI supports multiple frameworks and runtimes; it does not mandate a single agent framework or prevent adding others via the extensibility model.
- **Hosted or SaaS offering**: The CLI is a local tool; no requirement for a hosted service or mandatory cloud backend for the CLI itself.
- **Custom enterprise templates**: First release focuses on the defined set of frameworks, project types, pipelines, runtimes, and IaC; custom or private template catalogs are out of scope unless explicitly added in a later feature.

## Assumptions

- Users have or can obtain an Azure subscription and appropriate permissions to deploy to the chosen runtime.
- Users have `uv` (or equivalent) available for installation; Python ecosystem is acceptable for the CLI implementation.
- "Typical developer hardware" means a machine capable of running modern IDEs and container tooling; no specific minimum is mandated beyond that.
- Template versioning is linear (e.g. semver or date-based); upgrade applies to the next compatible template version.
- The defined option sets (framework, project type, pipeline, runtime, IaC) are sufficient for the first release; additional options can be added via the extensibility model later.
